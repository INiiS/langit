// This file is automatically generated, do not edit!
// Run scripts/generate-atp-schema.js to update this file.

export type CID = string;

export type DID = `did:${string}`;

export type Handle = string;

export type AtUri = string;

export type AtIdentifier = AtUri | Handle;

export interface AtBlob<T extends string = string> {
	$type: 'blob';
	mimeType: T;
	ref: {
		$link: string;
	};
	size: number;
}

export type ResponseOf<K extends keyof Queries | keyof Procedures> = K extends keyof Queries
	? Queries[K] extends { response: any }
		? Queries[K]['response']
		: unknown
	: K extends keyof Procedures
	  ? Procedures[K] extends { response: any }
			? Procedures[K]['response']
			: unknown
	  : never;

export type RefOf<K extends keyof Objects> = Objects[K];
export type UnionOf<K extends keyof Objects> = Objects[K] & { $type: K };

export interface Queries {
	/**
	 * Get private preferences attached to the account.
	 */
	'app.bsky.actor.getPreferences': {
		response: {
			preferences: RefOf<'app.bsky.actor.defs#preferences'>;
		};
	};
	'app.bsky.actor.getProfile': {
		params: {
			actor: string;
		};
		response: RefOf<'app.bsky.actor.defs#profileViewDetailed'>;
	};
	'app.bsky.actor.getProfiles': {
		params: {
			/**
			 * Maximum array length: 25
			 */
			actors: string[];
		};
		response: {
			profiles: RefOf<'app.bsky.actor.defs#profileViewDetailed'>[];
		};
	};
	/**
	 * Get a list of actors suggested for following. Used in discovery UIs.
	 */
	'app.bsky.actor.getSuggestions': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			actors: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Find actors (profiles) matching search criteria.
	 */
	'app.bsky.actor.searchActors': {
		params: {
			/**
			 * DEPRECATED: use 'q' instead
			 * @deprecated
			 */
			term?: string;
			/**
			 * search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended
			 */
			q?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 25
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			actors: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Find actor suggestions for a search term.
	 */
	'app.bsky.actor.searchActorsTypeahead': {
		params: {
			/**
			 * DEPRECATED: use 'q' instead
			 * @deprecated
			 */
			term?: string;
			/**
			 * search query prefix; not a full query string
			 */
			q?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 10
			 */
			limit?: number;
		};
		response: {
			actors: RefOf<'app.bsky.actor.defs#profileViewBasic'>[];
		};
	};
	/**
	 * Returns information about a given feed generator including TOS & offered feed URIs
	 */
	'app.bsky.feed.describeFeedGenerator': {
		response: {
			did: DID;
			feeds: RefOf<'app.bsky.feed.describeFeedGenerator#feed'>[];
			links?: RefOf<'app.bsky.feed.describeFeedGenerator#links'>;
		};
	};
	/**
	 * Retrieve a list of feeds created by a given actor
	 */
	'app.bsky.feed.getActorFeeds': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feeds: RefOf<'app.bsky.feed.defs#generatorView'>[];
		};
	};
	/**
	 * A view of the posts liked by an actor.
	 */
	'app.bsky.feed.getActorLikes': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
		errors: {
			BlockedActor: {};
			BlockedByActor: {};
		};
	};
	/**
	 * A view of an actor's feed.
	 */
	'app.bsky.feed.getAuthorFeed': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
			/**
			 * @default "posts_with_replies"
			 */
			filter?: 'posts_with_replies' | 'posts_no_replies' | 'posts_with_media' | (string & {});
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
		errors: {
			BlockedActor: {};
			BlockedByActor: {};
		};
	};
	/**
	 * Compose and hydrate a feed from a user's selected feed generator
	 */
	'app.bsky.feed.getFeed': {
		params: {
			feed: AtUri;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
		errors: {
			UnknownFeed: {};
		};
	};
	/**
	 * Get information about a specific feed offered by a feed generator, such as its online status
	 */
	'app.bsky.feed.getFeedGenerator': {
		params: {
			feed: AtUri;
		};
		response: {
			view: RefOf<'app.bsky.feed.defs#generatorView'>;
			isOnline: boolean;
			isValid: boolean;
		};
	};
	/**
	 * Get information about a list of feed generators
	 */
	'app.bsky.feed.getFeedGenerators': {
		params: {
			feeds: AtUri[];
		};
		response: {
			feeds: RefOf<'app.bsky.feed.defs#generatorView'>[];
		};
	};
	/**
	 * A skeleton of a feed provided by a feed generator
	 */
	'app.bsky.feed.getFeedSkeleton': {
		params: {
			feed: AtUri;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#skeletonFeedPost'>[];
		};
		errors: {
			UnknownFeed: {};
		};
	};
	'app.bsky.feed.getLikes': {
		params: {
			uri: AtUri;
			cid?: CID;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			uri: AtUri;
			cid?: CID;
			cursor?: string;
			likes: RefOf<'app.bsky.feed.getLikes#like'>[];
		};
	};
	/**
	 * A view of a recent posts from actors in a list
	 */
	'app.bsky.feed.getListFeed': {
		params: {
			list: AtUri;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
		errors: {
			UnknownList: {};
		};
	};
	'app.bsky.feed.getPostThread': {
		params: {
			uri: AtUri;
			/**
			 * Minimum: 0 \
			 * Maximum: 1000
			 * @default 6
			 */
			depth?: number;
			/**
			 * Minimum: 0 \
			 * Maximum: 1000
			 * @default 80
			 */
			parentHeight?: number;
		};
		response: {
			thread:
				| UnionOf<'app.bsky.feed.defs#threadViewPost'>
				| UnionOf<'app.bsky.feed.defs#notFoundPost'>
				| UnionOf<'app.bsky.feed.defs#blockedPost'>;
		};
		errors: {
			NotFound: {};
		};
	};
	/**
	 * A view of an actor's feed.
	 */
	'app.bsky.feed.getPosts': {
		params: {
			/**
			 * Maximum array length: 25
			 */
			uris: AtUri[];
		};
		response: {
			posts: RefOf<'app.bsky.feed.defs#postView'>[];
		};
	};
	'app.bsky.feed.getRepostedBy': {
		params: {
			uri: AtUri;
			cid?: CID;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			uri: AtUri;
			cid?: CID;
			cursor?: string;
			repostedBy: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Get a list of suggested feeds for the viewer.
	 */
	'app.bsky.feed.getSuggestedFeeds': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feeds: RefOf<'app.bsky.feed.defs#generatorView'>[];
		};
	};
	/**
	 * A view of the user's home timeline.
	 */
	'app.bsky.feed.getTimeline': {
		params: {
			algorithm?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
	};
	/**
	 * Find posts matching search criteria
	 */
	'app.bsky.feed.searchPosts': {
		params: {
			/**
			 * search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended
			 */
			q: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 25
			 */
			limit?: number;
			/**
			 * optional pagination mechanism; may not necessarily allow scrolling through entire result set
			 */
			cursor?: string;
		};
		response: {
			cursor?: string;
			/**
			 * count of search hits. optional, may be rounded/truncated, and may not be possible to paginate through all hits
			 */
			hitsTotal?: number;
			posts: RefOf<'app.bsky.feed.defs#postView'>[];
		};
		errors: {
			BadQueryString: {};
		};
	};
	/**
	 * Who is the requester's account blocking?
	 */
	'app.bsky.graph.getBlocks': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			blocks: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Who is following an actor?
	 */
	'app.bsky.graph.getFollowers': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			subject: RefOf<'app.bsky.actor.defs#profileView'>;
			cursor?: string;
			followers: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Who is an actor following?
	 */
	'app.bsky.graph.getFollows': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			subject: RefOf<'app.bsky.actor.defs#profileView'>;
			cursor?: string;
			follows: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Fetch a list of actors
	 */
	'app.bsky.graph.getList': {
		params: {
			list: AtUri;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			list: RefOf<'app.bsky.graph.defs#listView'>;
			items: RefOf<'app.bsky.graph.defs#listItemView'>[];
		};
	};
	/**
	 * Which lists is the requester's account blocking?
	 */
	'app.bsky.graph.getListBlocks': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			lists: RefOf<'app.bsky.graph.defs#listView'>[];
		};
	};
	/**
	 * Which lists is the requester's account muting?
	 */
	'app.bsky.graph.getListMutes': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			lists: RefOf<'app.bsky.graph.defs#listView'>[];
		};
	};
	/**
	 * Fetch a list of lists that belong to an actor
	 */
	'app.bsky.graph.getLists': {
		params: {
			actor: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			lists: RefOf<'app.bsky.graph.defs#listView'>[];
		};
	};
	/**
	 * Who does the viewer mute?
	 */
	'app.bsky.graph.getMutes': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			mutes: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	/**
	 * Get suggested follows related to a given actor.
	 */
	'app.bsky.graph.getSuggestedFollowsByActor': {
		params: {
			actor: string;
		};
		response: {
			suggestions: RefOf<'app.bsky.actor.defs#profileView'>[];
		};
	};
	'app.bsky.notification.getUnreadCount': {
		params: {
			seenAt?: string;
		};
		response: {
			count: number;
		};
	};
	'app.bsky.notification.listNotifications': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
			seenAt?: string;
		};
		response: {
			cursor?: string;
			notifications: RefOf<'app.bsky.notification.listNotifications#notification'>[];
		};
	};
	/**
	 * DEPRECATED: will be removed soon, please find a feed generator alternative
	 * @deprecated
	 */
	'app.bsky.unspecced.getPopular': {
		params: {
			/**
			 * @default false
			 */
			includeNsfw?: boolean;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#feedViewPost'>[];
		};
	};
	/**
	 * An unspecced view of globally popular feed generators
	 */
	'app.bsky.unspecced.getPopularFeedGenerators': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
			query?: string;
		};
		response: {
			cursor?: string;
			feeds: RefOf<'app.bsky.feed.defs#generatorView'>[];
		};
	};
	/**
	 * A skeleton of a timeline - UNSPECCED & WILL GO AWAY SOON
	 */
	'app.bsky.unspecced.getTimelineSkeleton': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			feed: RefOf<'app.bsky.feed.defs#skeletonFeedPost'>[];
		};
		errors: {
			UnknownFeed: {};
		};
	};
	/**
	 * Backend Actors (profile) search, returning only skeleton
	 */
	'app.bsky.unspecced.searchActorsSkeleton': {
		params: {
			/**
			 * search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended. For typeahead search, only simple term match is supported, not full syntax
			 */
			q: string;
			/**
			 * if true, acts as fast/simple 'typeahead' query
			 */
			typeahead?: boolean;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 25
			 */
			limit?: number;
			/**
			 * optional pagination mechanism; may not necessarily allow scrolling through entire result set
			 */
			cursor?: string;
		};
		response: {
			cursor?: string;
			/**
			 * count of search hits. optional, may be rounded/truncated, and may not be possible to paginate through all hits
			 */
			hitsTotal?: number;
			actors: RefOf<'app.bsky.unspecced.defs#skeletonSearchActor'>[];
		};
		errors: {
			BadQueryString: {};
		};
	};
	/**
	 * Backend Posts search, returning only skeleton
	 */
	'app.bsky.unspecced.searchPostsSkeleton': {
		params: {
			/**
			 * search query string; syntax, phrase, boolean, and faceting is unspecified, but Lucene query syntax is recommended
			 */
			q: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 25
			 */
			limit?: number;
			/**
			 * optional pagination mechanism; may not necessarily allow scrolling through entire result set
			 */
			cursor?: string;
		};
		response: {
			cursor?: string;
			/**
			 * count of search hits. optional, may be rounded/truncated, and may not be possible to paginate through all hits
			 */
			hitsTotal?: number;
			posts: RefOf<'app.bsky.unspecced.defs#skeletonSearchPost'>[];
		};
		errors: {
			BadQueryString: {};
		};
	};
	/**
	 * View details about an account.
	 */
	'com.atproto.admin.getAccountInfo': {
		params: {
			did: DID;
		};
		response: RefOf<'com.atproto.admin.defs#accountView'>;
	};
	/**
	 * Admin view of invite codes
	 */
	'com.atproto.admin.getInviteCodes': {
		params: {
			/**
			 * @default "recent"
			 */
			sort?: 'recent' | 'usage' | (string & {});
			/**
			 * Minimum: 1 \
			 * Maximum: 500
			 * @default 100
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			codes: RefOf<'com.atproto.server.defs#inviteCode'>[];
		};
	};
	/**
	 * View details about a moderation action.
	 */
	'com.atproto.admin.getModerationAction': {
		params: {
			id: number;
		};
		response: RefOf<'com.atproto.admin.defs#actionViewDetail'>;
	};
	/**
	 * List moderation actions related to a subject.
	 */
	'com.atproto.admin.getModerationActions': {
		params: {
			subject?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			actions: RefOf<'com.atproto.admin.defs#actionView'>[];
		};
	};
	/**
	 * View details about a moderation report.
	 */
	'com.atproto.admin.getModerationReport': {
		params: {
			id: number;
		};
		response: RefOf<'com.atproto.admin.defs#reportViewDetail'>;
	};
	/**
	 * List moderation reports related to a subject.
	 */
	'com.atproto.admin.getModerationReports': {
		params: {
			subject?: string;
			ignoreSubjects?: string[];
			/**
			 * Get all reports that were actioned by a specific moderator
			 */
			actionedBy?: DID;
			/**
			 * Filter reports made by one or more DIDs
			 */
			reporters?: string[];
			resolved?: boolean;
			actionType?:
				| 'com.atproto.admin.defs#takedown'
				| 'com.atproto.admin.defs#flag'
				| 'com.atproto.admin.defs#acknowledge'
				| 'com.atproto.admin.defs#escalate'
				| (string & {});
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
			/**
			 * Reverse the order of the returned records? when true, returns reports in chronological order
			 */
			reverse?: boolean;
		};
		response: {
			cursor?: string;
			reports: RefOf<'com.atproto.admin.defs#reportView'>[];
		};
	};
	/**
	 * View details about a record.
	 */
	'com.atproto.admin.getRecord': {
		params: {
			uri: AtUri;
			cid?: CID;
		};
		response: RefOf<'com.atproto.admin.defs#recordViewDetail'>;
		errors: {
			RecordNotFound: {};
		};
	};
	/**
	 * View details about a repository.
	 */
	'com.atproto.admin.getRepo': {
		params: {
			did: DID;
		};
		response: RefOf<'com.atproto.admin.defs#repoViewDetail'>;
		errors: {
			RepoNotFound: {};
		};
	};
	/**
	 * Fetch the service-specific the admin status of a subject (account, record, or blob)
	 */
	'com.atproto.admin.getSubjectStatus': {
		params: {
			did?: DID;
			uri?: AtUri;
			blob?: CID;
		};
		response: {
			subject:
				| UnionOf<'com.atproto.admin.defs#repoRef'>
				| UnionOf<'com.atproto.repo.strongRef'>
				| UnionOf<'com.atproto.admin.defs#repoBlobRef'>;
			takedown?: RefOf<'com.atproto.admin.defs#statusAttr'>;
		};
	};
	/**
	 * Find repositories based on a search term.
	 */
	'com.atproto.admin.searchRepos': {
		params: {
			/**
			 * DEPRECATED: use 'q' instead
			 * @deprecated
			 */
			term?: string;
			q?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			repos: RefOf<'com.atproto.admin.defs#repoView'>[];
		};
	};
	/**
	 * Provides the DID of a repo.
	 */
	'com.atproto.identity.resolveHandle': {
		params: {
			/**
			 * The handle to resolve.
			 */
			handle: Handle;
		};
		response: {
			did: DID;
		};
	};
	/**
	 * Find labels relevant to the provided URI patterns.
	 */
	'com.atproto.label.queryLabels': {
		params: {
			/**
			 * List of AT URI patterns to match (boolean 'OR'). Each may be a prefix (ending with '*'; will match inclusive of the string leading to '*'), or a full URI
			 */
			uriPatterns: string[];
			/**
			 * Optional list of label sources (DIDs) to filter on
			 */
			sources?: DID[];
			/**
			 * Minimum: 1 \
			 * Maximum: 250
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			labels: RefOf<'com.atproto.label.defs#label'>[];
		};
	};
	/**
	 * Get information about the repo, including the list of collections.
	 */
	'com.atproto.repo.describeRepo': {
		params: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
		};
		response: {
			handle: Handle;
			did: DID;
			didDoc: unknown;
			collections: string[];
			handleIsCorrect: boolean;
		};
	};
	/**
	 * Get a record.
	 */
	'com.atproto.repo.getRecord': {
		params: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * The NSID of the record collection.
			 */
			collection: string;
			/**
			 * The key of the record.
			 */
			rkey: string;
			/**
			 * The CID of the version of the record. If not specified, then return the most recent version.
			 */
			cid?: CID;
		};
		response: {
			uri: AtUri;
			cid?: CID;
			value: unknown;
		};
	};
	/**
	 * List a range of records in a collection.
	 */
	'com.atproto.repo.listRecords': {
		params: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * The NSID of the record type.
			 */
			collection: string;
			/**
			 * The number of records to return. \
			 * Minimum: 1 \
			 * Maximum: 100
			 * @default 50
			 */
			limit?: number;
			cursor?: string;
			/**
			 * DEPRECATED: The lowest sort-ordered rkey to start from (exclusive)
			 * @deprecated
			 */
			rkeyStart?: string;
			/**
			 * DEPRECATED: The highest sort-ordered rkey to stop at (exclusive)
			 * @deprecated
			 */
			rkeyEnd?: string;
			/**
			 * Reverse the order of the returned records?
			 */
			reverse?: boolean;
		};
		response: {
			cursor?: string;
			records: RefOf<'com.atproto.repo.listRecords#record'>[];
		};
	};
	/**
	 * Get a document describing the service's accounts configuration.
	 */
	'com.atproto.server.describeServer': {
		response: {
			inviteCodeRequired?: boolean;
			availableUserDomains: string[];
			links?: RefOf<'com.atproto.server.describeServer#links'>;
		};
	};
	/**
	 * Get all invite codes for a given account
	 */
	'com.atproto.server.getAccountInviteCodes': {
		params: {
			/**
			 * @default true
			 */
			includeUsed?: boolean;
			/**
			 * @default true
			 */
			createAvailable?: boolean;
		};
		response: {
			codes: RefOf<'com.atproto.server.defs#inviteCode'>[];
		};
		errors: {
			DuplicateCreate: {};
		};
	};
	/**
	 * Get information about the current session.
	 */
	'com.atproto.server.getSession': {
		response: {
			handle: Handle;
			did: DID;
			email?: string;
			emailConfirmed?: boolean;
			didDoc?: unknown;
		};
	};
	/**
	 * List all app-specific passwords.
	 */
	'com.atproto.server.listAppPasswords': {
		response: {
			passwords: RefOf<'com.atproto.server.listAppPasswords#appPassword'>[];
		};
		errors: {
			AccountTakedown: {};
		};
	};
	/**
	 * Get a blob associated with a given repo.
	 */
	'com.atproto.sync.getBlob': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
			/**
			 * The CID of the blob to fetch
			 */
			cid: CID;
		};
		response: unknown;
	};
	/**
	 * Gets blocks from a given repo.
	 */
	'com.atproto.sync.getBlocks': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
			cids: CID[];
		};
		response: unknown;
	};
	/**
	 * DEPRECATED - please use com.atproto.sync.getRepo instead
	 * @deprecated
	 */
	'com.atproto.sync.getCheckout': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
		};
		response: unknown;
	};
	/**
	 * DEPRECATED - please use com.atproto.sync.getLatestCommit instead
	 * @deprecated
	 */
	'com.atproto.sync.getHead': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
		};
		response: {
			root: CID;
		};
		errors: {
			HeadNotFound: {};
		};
	};
	/**
	 * Gets the current commit CID & revision of the repo.
	 */
	'com.atproto.sync.getLatestCommit': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
		};
		response: {
			cid: CID;
			rev: string;
		};
		errors: {
			RepoNotFound: {};
		};
	};
	/**
	 * Gets blocks needed for existence or non-existence of record.
	 */
	'com.atproto.sync.getRecord': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
			collection: string;
			rkey: string;
			/**
			 * An optional past commit CID.
			 */
			commit?: CID;
		};
		response: unknown;
	};
	/**
	 * Gets the did's repo, optionally catching up from a specific revision.
	 */
	'com.atproto.sync.getRepo': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
			/**
			 * The revision of the repo to catch up from.
			 */
			since?: string;
		};
		response: unknown;
	};
	/**
	 * List blob cids since some revision
	 */
	'com.atproto.sync.listBlobs': {
		params: {
			/**
			 * The DID of the repo.
			 */
			did: DID;
			/**
			 * Optional revision of the repo to list blobs since
			 */
			since?: string;
			/**
			 * Minimum: 1 \
			 * Maximum: 1000
			 * @default 500
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			cids: CID[];
		};
	};
	/**
	 * List dids and root cids of hosted repos
	 */
	'com.atproto.sync.listRepos': {
		params: {
			/**
			 * Minimum: 1 \
			 * Maximum: 1000
			 * @default 500
			 */
			limit?: number;
			cursor?: string;
		};
		response: {
			cursor?: string;
			repos: RefOf<'com.atproto.sync.listRepos#repo'>[];
		};
	};
}

export interface Procedures {
	/**
	 * Sets the private preferences attached to the account.
	 */
	'app.bsky.actor.putPreferences': {
		data: {
			preferences: RefOf<'app.bsky.actor.defs#preferences'>;
		};
	};
	/**
	 * Mute an actor by did or handle.
	 */
	'app.bsky.graph.muteActor': {
		data: {
			actor: string;
		};
	};
	/**
	 * Mute a list of actors.
	 */
	'app.bsky.graph.muteActorList': {
		data: {
			list: AtUri;
		};
	};
	/**
	 * Unmute an actor by did or handle.
	 */
	'app.bsky.graph.unmuteActor': {
		data: {
			actor: string;
		};
	};
	/**
	 * Unmute a list of actors.
	 */
	'app.bsky.graph.unmuteActorList': {
		data: {
			list: AtUri;
		};
	};
	/**
	 * Register for push notifications with a service
	 */
	'app.bsky.notification.registerPush': {
		data: {
			serviceDid: DID;
			token: string;
			platform: 'ios' | 'android' | 'web' | (string & {});
			appId: string;
		};
	};
	/**
	 * Notify server that the user has seen notifications.
	 */
	'app.bsky.notification.updateSeen': {
		data: {
			seenAt: string;
		};
	};
	/**
	 * Disable an account from receiving new invite codes, but does not invalidate existing codes
	 */
	'com.atproto.admin.disableAccountInvites': {
		data: {
			account: DID;
			/**
			 * Additionally add a note describing why the invites were disabled
			 */
			note?: string;
		};
	};
	/**
	 * Disable some set of codes and/or all codes associated with a set of users
	 */
	'com.atproto.admin.disableInviteCodes': {
		data: {
			codes?: string[];
			accounts?: string[];
		};
	};
	/**
	 * Re-enable an accounts ability to receive invite codes
	 */
	'com.atproto.admin.enableAccountInvites': {
		data: {
			account: DID;
			/**
			 * Additionally add a note describing why the invites were enabled
			 */
			note?: string;
		};
	};
	/**
	 * Resolve moderation reports by an action.
	 */
	'com.atproto.admin.resolveModerationReports': {
		data: {
			actionId: number;
			reportIds: number[];
			createdBy: DID;
		};
		response: RefOf<'com.atproto.admin.defs#actionView'>;
	};
	/**
	 * Reverse a moderation action.
	 */
	'com.atproto.admin.reverseModerationAction': {
		data: {
			id: number;
			reason: string;
			createdBy: DID;
		};
		response: RefOf<'com.atproto.admin.defs#actionView'>;
	};
	/**
	 * Send email to a user's primary email address
	 */
	'com.atproto.admin.sendEmail': {
		data: {
			recipientDid: DID;
			content: string;
			subject?: string;
		};
		response: {
			sent: boolean;
		};
	};
	/**
	 * Take a moderation action on a repo.
	 */
	'com.atproto.admin.takeModerationAction': {
		data: {
			action:
				| 'com.atproto.admin.defs#takedown'
				| 'com.atproto.admin.defs#flag'
				| 'com.atproto.admin.defs#acknowledge'
				| (string & {});
			subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
			subjectBlobCids?: CID[];
			createLabelVals?: string[];
			negateLabelVals?: string[];
			reason: string;
			/**
			 * Indicates how long this action was meant to be in effect before automatically expiring.
			 */
			durationInHours?: number;
			createdBy: DID;
		};
		response: RefOf<'com.atproto.admin.defs#actionView'>;
		errors: {
			SubjectHasAction: {};
		};
	};
	/**
	 * Administrative action to update an account's email
	 */
	'com.atproto.admin.updateAccountEmail': {
		data: {
			/**
			 * The handle or DID of the repo.
			 */
			account: string;
			email: string;
		};
	};
	/**
	 * Administrative action to update an account's handle
	 */
	'com.atproto.admin.updateAccountHandle': {
		data: {
			did: DID;
			handle: Handle;
		};
	};
	/**
	 * Update the service-specific admin status of a subject (account, record, or blob)
	 */
	'com.atproto.admin.updateSubjectStatus': {
		data: {
			subject:
				| UnionOf<'com.atproto.admin.defs#repoRef'>
				| UnionOf<'com.atproto.repo.strongRef'>
				| UnionOf<'com.atproto.admin.defs#repoBlobRef'>;
			takedown?: RefOf<'com.atproto.admin.defs#statusAttr'>;
		};
		response: {
			subject:
				| UnionOf<'com.atproto.admin.defs#repoRef'>
				| UnionOf<'com.atproto.repo.strongRef'>
				| UnionOf<'com.atproto.admin.defs#repoBlobRef'>;
			takedown?: RefOf<'com.atproto.admin.defs#statusAttr'>;
		};
	};
	/**
	 * Updates the handle of the account
	 */
	'com.atproto.identity.updateHandle': {
		data: {
			handle: Handle;
		};
	};
	/**
	 * Report a repo or a record.
	 */
	'com.atproto.moderation.createReport': {
		data: {
			reasonType: RefOf<'com.atproto.moderation.defs#reasonType'>;
			reason?: string;
			subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
		};
		response: {
			id: number;
			reasonType: RefOf<'com.atproto.moderation.defs#reasonType'>;
			/**
			 * Maximum string length: 20000 \
			 * Maximum grapheme length: 2000
			 */
			reason?: string;
			subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
			reportedBy: DID;
			createdAt: string;
		};
	};
	/**
	 * Apply a batch transaction of creates, updates, and deletes.
	 */
	'com.atproto.repo.applyWrites': {
		data: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * Validate the records?
			 * @default true
			 */
			validate?: boolean;
			writes: (
				| UnionOf<'com.atproto.repo.applyWrites#create'>
				| UnionOf<'com.atproto.repo.applyWrites#update'>
				| UnionOf<'com.atproto.repo.applyWrites#delete'>
			)[];
			swapCommit?: CID;
		};
		errors: {
			InvalidSwap: {};
		};
	};
	/**
	 * Create a new record.
	 */
	'com.atproto.repo.createRecord': {
		data: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * The NSID of the record collection.
			 */
			collection: string;
			/**
			 * The key of the record. \
			 * Maximum string length: 15
			 */
			rkey?: string;
			/**
			 * Validate the record?
			 * @default true
			 */
			validate?: boolean;
			/**
			 * The record to create.
			 */
			record: unknown;
			/**
			 * Compare and swap with the previous commit by cid.
			 */
			swapCommit?: CID;
		};
		response: {
			uri: AtUri;
			cid: CID;
		};
		errors: {
			InvalidSwap: {};
		};
	};
	/**
	 * Delete a record, or ensure it doesn't exist.
	 */
	'com.atproto.repo.deleteRecord': {
		data: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * The NSID of the record collection.
			 */
			collection: string;
			/**
			 * The key of the record.
			 */
			rkey: string;
			/**
			 * Compare and swap with the previous record by cid.
			 */
			swapRecord?: CID;
			/**
			 * Compare and swap with the previous commit by cid.
			 */
			swapCommit?: CID;
		};
		errors: {
			InvalidSwap: {};
		};
	};
	/**
	 * Write a record, creating or updating it as needed.
	 */
	'com.atproto.repo.putRecord': {
		data: {
			/**
			 * The handle or DID of the repo.
			 */
			repo: string;
			/**
			 * The NSID of the record collection.
			 */
			collection: string;
			/**
			 * The key of the record. \
			 * Maximum string length: 15
			 */
			rkey: string;
			/**
			 * Validate the record?
			 * @default true
			 */
			validate?: boolean;
			/**
			 * The record to write.
			 */
			record: unknown;
			/**
			 * Compare and swap with the previous record by cid.
			 */
			swapRecord?: CID;
			/**
			 * Compare and swap with the previous commit by cid.
			 */
			swapCommit?: CID;
		};
		response: {
			uri: AtUri;
			cid: CID;
		};
		errors: {
			InvalidSwap: {};
		};
	};
	/**
	 * Upload a new blob to be added to repo in a later request.
	 */
	'com.atproto.repo.uploadBlob': {
		data: Blob;
		response: {
			blob: AtBlob;
		};
	};
	/**
	 * Confirm an email using a token from com.atproto.server.requestEmailConfirmation.
	 */
	'com.atproto.server.confirmEmail': {
		data: {
			email: string;
			token: string;
		};
		errors: {
			AccountNotFound: {};
			ExpiredToken: {};
			InvalidToken: {};
			InvalidEmail: {};
		};
	};
	/**
	 * Create an account.
	 */
	'com.atproto.server.createAccount': {
		data: {
			email?: string;
			handle: Handle;
			did?: DID;
			inviteCode?: string;
			password?: string;
			recoveryKey?: string;
			plcOp?: unknown;
		};
		response: {
			accessJwt: string;
			refreshJwt: string;
			handle: Handle;
			did: DID;
			didDoc?: unknown;
		};
		errors: {
			InvalidHandle: {};
			InvalidPassword: {};
			InvalidInviteCode: {};
			HandleNotAvailable: {};
			UnsupportedDomain: {};
			UnresolvableDid: {};
			IncompatibleDidDoc: {};
		};
	};
	/**
	 * Create an app-specific password.
	 */
	'com.atproto.server.createAppPassword': {
		data: {
			name: string;
		};
		response: RefOf<'com.atproto.server.createAppPassword#appPassword'>;
		errors: {
			AccountTakedown: {};
		};
	};
	/**
	 * Create an invite code.
	 */
	'com.atproto.server.createInviteCode': {
		data: {
			useCount: number;
			forAccount?: DID;
		};
		response: {
			code: string;
		};
	};
	/**
	 * Create an invite code.
	 */
	'com.atproto.server.createInviteCodes': {
		data: {
			/**
			 * @default 1
			 */
			codeCount: number;
			useCount: number;
			forAccounts?: DID[];
		};
		response: {
			codes: RefOf<'com.atproto.server.createInviteCodes#accountCodes'>[];
		};
	};
	/**
	 * Create an authentication session.
	 */
	'com.atproto.server.createSession': {
		data: {
			/**
			 * Handle or other identifier supported by the server for the authenticating user.
			 */
			identifier: string;
			password: string;
		};
		response: {
			accessJwt: string;
			refreshJwt: string;
			handle: Handle;
			did: DID;
			didDoc?: unknown;
			email?: string;
			emailConfirmed?: boolean;
		};
		errors: {
			AccountTakedown: {};
		};
	};
	/**
	 * Delete a user account with a token and password.
	 */
	'com.atproto.server.deleteAccount': {
		data: {
			did: DID;
			password: string;
			token: string;
		};
		errors: {
			ExpiredToken: {};
			InvalidToken: {};
		};
	};
	/**
	 * Delete the current session.
	 */
	'com.atproto.server.deleteSession': {};
	/**
	 * Refresh an authentication session.
	 */
	'com.atproto.server.refreshSession': {
		response: {
			accessJwt: string;
			refreshJwt: string;
			handle: Handle;
			did: DID;
			didDoc?: unknown;
		};
		errors: {
			AccountTakedown: {};
		};
	};
	/**
	 * Initiate a user account deletion via email.
	 */
	'com.atproto.server.requestAccountDelete': {};
	/**
	 * Request an email with a code to confirm ownership of email
	 */
	'com.atproto.server.requestEmailConfirmation': {};
	/**
	 * Request a token in order to update email.
	 */
	'com.atproto.server.requestEmailUpdate': {
		response: {
			tokenRequired: boolean;
		};
	};
	/**
	 * Initiate a user account password reset via email.
	 */
	'com.atproto.server.requestPasswordReset': {
		data: {
			email: string;
		};
	};
	/**
	 * Reserve a repo signing key for account creation.
	 */
	'com.atproto.server.reserveSigningKey': {
		data: {
			/**
			 * The did to reserve a new did:key for
			 */
			did?: string;
		};
		response: {
			/**
			 * Public signing key in the form of a did:key.
			 */
			signingKey: string;
		};
	};
	/**
	 * Reset a user account password using a token.
	 */
	'com.atproto.server.resetPassword': {
		data: {
			token: string;
			password: string;
		};
		errors: {
			ExpiredToken: {};
			InvalidToken: {};
		};
	};
	/**
	 * Revoke an app-specific password by name.
	 */
	'com.atproto.server.revokeAppPassword': {
		data: {
			name: string;
		};
	};
	/**
	 * Update an account's email.
	 */
	'com.atproto.server.updateEmail': {
		data: {
			email: string;
			/**
			 * Requires a token from com.atproto.sever.requestEmailUpdate if the account's email has been confirmed.
			 */
			token?: string;
		};
		errors: {
			ExpiredToken: {};
			InvalidToken: {};
			TokenRequired: {};
		};
	};
	/**
	 * Notify a crawling service of a recent update. Often when a long break between updates causes the connection with the crawling service to break.
	 */
	'com.atproto.sync.notifyOfUpdate': {
		data: {
			/**
			 * Hostname of the service that is notifying of update.
			 */
			hostname: string;
		};
	};
	/**
	 * Request a service to persistently crawl hosted repos.
	 */
	'com.atproto.sync.requestCrawl': {
		data: {
			/**
			 * Hostname of the service that is requesting to be crawled.
			 */
			hostname: string;
		};
	};
}

export interface Subscriptions {}

export interface Objects {
	'app.bsky.actor.defs#profileViewBasic': {
		did: DID;
		handle: Handle;
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		avatar?: string;
		viewer?: RefOf<'app.bsky.actor.defs#viewerState'>;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
	};
	'app.bsky.actor.defs#profileView': {
		did: DID;
		handle: Handle;
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		/**
		 * Maximum string length: 2560 \
		 * Maximum grapheme length: 256
		 */
		description?: string;
		avatar?: string;
		indexedAt?: string;
		viewer?: RefOf<'app.bsky.actor.defs#viewerState'>;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
	};
	'app.bsky.actor.defs#profileViewDetailed': {
		did: DID;
		handle: Handle;
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		/**
		 * Maximum string length: 2560 \
		 * Maximum grapheme length: 256
		 */
		description?: string;
		avatar?: string;
		banner?: string;
		followersCount?: number;
		followsCount?: number;
		postsCount?: number;
		indexedAt?: string;
		viewer?: RefOf<'app.bsky.actor.defs#viewerState'>;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
	};
	'app.bsky.actor.defs#viewerState': {
		muted?: boolean;
		mutedByList?: RefOf<'app.bsky.graph.defs#listViewBasic'>;
		blockedBy?: boolean;
		blocking?: AtUri;
		blockingByList?: RefOf<'app.bsky.graph.defs#listViewBasic'>;
		following?: AtUri;
		followedBy?: AtUri;
	};
	'app.bsky.actor.defs#preferences': (
		| UnionOf<'app.bsky.actor.defs#adultContentPref'>
		| UnionOf<'app.bsky.actor.defs#contentLabelPref'>
		| UnionOf<'app.bsky.actor.defs#savedFeedsPref'>
		| UnionOf<'app.bsky.actor.defs#personalDetailsPref'>
		| UnionOf<'app.bsky.actor.defs#feedViewPref'>
		| UnionOf<'app.bsky.actor.defs#threadViewPref'>
	)[];
	'app.bsky.actor.defs#adultContentPref': {
		/**
		 * @default false
		 */
		enabled: boolean;
	};
	'app.bsky.actor.defs#contentLabelPref': {
		label: string;
		visibility: 'show' | 'warn' | 'hide' | (string & {});
	};
	'app.bsky.actor.defs#savedFeedsPref': {
		pinned: AtUri[];
		saved: AtUri[];
	};
	'app.bsky.actor.defs#personalDetailsPref': {
		/**
		 * The birth date of the owner of the account.
		 */
		birthDate?: string;
	};
	'app.bsky.actor.defs#feedViewPref': {
		/**
		 * The URI of the feed, or an identifier which describes the feed.
		 */
		feed: string;
		/**
		 * Hide replies in the feed.
		 */
		hideReplies?: boolean;
		/**
		 * Hide replies in the feed if they are not by followed users.
		 */
		hideRepliesByUnfollowed?: boolean;
		/**
		 * Hide replies in the feed if they do not have this number of likes.
		 */
		hideRepliesByLikeCount?: number;
		/**
		 * Hide reposts in the feed.
		 */
		hideReposts?: boolean;
		/**
		 * Hide quote posts in the feed.
		 */
		hideQuotePosts?: boolean;
	};
	'app.bsky.actor.defs#threadViewPref': {
		/**
		 * Sorting mode.
		 */
		sort?: 'oldest' | 'newest' | 'most-likes' | 'random' | (string & {});
		/**
		 * Show followed users at the top of all replies.
		 */
		prioritizeFollowedUsers?: boolean;
	};
	'app.bsky.embed.external': {
		external: RefOf<'app.bsky.embed.external#external'>;
	};
	'app.bsky.embed.external#external': {
		uri: string;
		title: string;
		description: string;
		thumb?: AtBlob<`image/${string}`>;
	};
	'app.bsky.embed.external#view': {
		external: RefOf<'app.bsky.embed.external#viewExternal'>;
	};
	'app.bsky.embed.external#viewExternal': {
		uri: string;
		title: string;
		description: string;
		thumb?: string;
	};
	'app.bsky.embed.images': {
		/**
		 * Maximum array length: 4
		 */
		images: RefOf<'app.bsky.embed.images#image'>[];
	};
	'app.bsky.embed.images#image': {
		image: AtBlob<`image/${string}`>;
		alt: string;
		aspectRatio?: RefOf<'app.bsky.embed.images#aspectRatio'>;
	};
	/**
	 * width:height represents an aspect ratio. It may be approximate, and may not correspond to absolute dimensions in any given unit.
	 */
	'app.bsky.embed.images#aspectRatio': {
		/**
		 * Minimum: 1
		 */
		width: number;
		/**
		 * Minimum: 1
		 */
		height: number;
	};
	'app.bsky.embed.images#view': {
		/**
		 * Maximum array length: 4
		 */
		images: RefOf<'app.bsky.embed.images#viewImage'>[];
	};
	'app.bsky.embed.images#viewImage': {
		thumb: string;
		fullsize: string;
		alt: string;
		aspectRatio?: RefOf<'app.bsky.embed.images#aspectRatio'>;
	};
	'app.bsky.embed.record': {
		record: RefOf<'com.atproto.repo.strongRef'>;
	};
	'app.bsky.embed.record#view': {
		record:
			| UnionOf<'app.bsky.embed.record#viewRecord'>
			| UnionOf<'app.bsky.embed.record#viewNotFound'>
			| UnionOf<'app.bsky.embed.record#viewBlocked'>
			| UnionOf<'app.bsky.feed.defs#generatorView'>
			| UnionOf<'app.bsky.graph.defs#listView'>;
	};
	'app.bsky.embed.record#viewRecord': {
		uri: AtUri;
		cid: CID;
		author: RefOf<'app.bsky.actor.defs#profileViewBasic'>;
		value: unknown;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
		embeds?: (
			| UnionOf<'app.bsky.embed.images#view'>
			| UnionOf<'app.bsky.embed.external#view'>
			| UnionOf<'app.bsky.embed.record#view'>
			| UnionOf<'app.bsky.embed.recordWithMedia#view'>
		)[];
		indexedAt: string;
	};
	'app.bsky.embed.record#viewNotFound': {
		uri: AtUri;
		notFound: boolean;
	};
	'app.bsky.embed.record#viewBlocked': {
		uri: AtUri;
		blocked: boolean;
		author: RefOf<'app.bsky.feed.defs#blockedAuthor'>;
	};
	'app.bsky.embed.recordWithMedia': {
		record: RefOf<'app.bsky.embed.record'>;
		media: UnionOf<'app.bsky.embed.images'> | UnionOf<'app.bsky.embed.external'>;
	};
	'app.bsky.embed.recordWithMedia#view': {
		record: RefOf<'app.bsky.embed.record#view'>;
		media: UnionOf<'app.bsky.embed.images#view'> | UnionOf<'app.bsky.embed.external#view'>;
	};
	'app.bsky.feed.defs#postView': {
		uri: AtUri;
		cid: CID;
		author: RefOf<'app.bsky.actor.defs#profileViewBasic'>;
		record: unknown;
		embed?:
			| UnionOf<'app.bsky.embed.images#view'>
			| UnionOf<'app.bsky.embed.external#view'>
			| UnionOf<'app.bsky.embed.record#view'>
			| UnionOf<'app.bsky.embed.recordWithMedia#view'>;
		replyCount?: number;
		repostCount?: number;
		likeCount?: number;
		indexedAt: string;
		viewer?: RefOf<'app.bsky.feed.defs#viewerState'>;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
		threadgate?: RefOf<'app.bsky.feed.defs#threadgateView'>;
	};
	'app.bsky.feed.defs#viewerState': {
		repost?: AtUri;
		like?: AtUri;
	};
	'app.bsky.feed.defs#feedViewPost': {
		post: RefOf<'app.bsky.feed.defs#postView'>;
		reply?: RefOf<'app.bsky.feed.defs#replyRef'>;
		reason?: UnionOf<'app.bsky.feed.defs#reasonRepost'>;
	};
	'app.bsky.feed.defs#replyRef': {
		root:
			| UnionOf<'app.bsky.feed.defs#postView'>
			| UnionOf<'app.bsky.feed.defs#notFoundPost'>
			| UnionOf<'app.bsky.feed.defs#blockedPost'>;
		parent:
			| UnionOf<'app.bsky.feed.defs#postView'>
			| UnionOf<'app.bsky.feed.defs#notFoundPost'>
			| UnionOf<'app.bsky.feed.defs#blockedPost'>;
	};
	'app.bsky.feed.defs#reasonRepost': {
		by: RefOf<'app.bsky.actor.defs#profileViewBasic'>;
		indexedAt: string;
	};
	'app.bsky.feed.defs#threadViewPost': {
		post: RefOf<'app.bsky.feed.defs#postView'>;
		parent?:
			| UnionOf<'app.bsky.feed.defs#threadViewPost'>
			| UnionOf<'app.bsky.feed.defs#notFoundPost'>
			| UnionOf<'app.bsky.feed.defs#blockedPost'>;
		replies?: (
			| UnionOf<'app.bsky.feed.defs#threadViewPost'>
			| UnionOf<'app.bsky.feed.defs#notFoundPost'>
			| UnionOf<'app.bsky.feed.defs#blockedPost'>
		)[];
		viewer?: RefOf<'app.bsky.feed.defs#viewerThreadState'>;
	};
	'app.bsky.feed.defs#notFoundPost': {
		uri: AtUri;
		notFound: boolean;
	};
	'app.bsky.feed.defs#blockedPost': {
		uri: AtUri;
		blocked: boolean;
		author: RefOf<'app.bsky.feed.defs#blockedAuthor'>;
	};
	'app.bsky.feed.defs#blockedAuthor': {
		did: DID;
		viewer?: RefOf<'app.bsky.actor.defs#viewerState'>;
	};
	'app.bsky.feed.defs#viewerThreadState': {
		canReply?: boolean;
	};
	'app.bsky.feed.defs#generatorView': {
		uri: AtUri;
		cid: CID;
		did: DID;
		creator: RefOf<'app.bsky.actor.defs#profileView'>;
		displayName: string;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: RefOf<'app.bsky.richtext.facet'>[];
		avatar?: string;
		/**
		 * Minimum: 0
		 */
		likeCount?: number;
		viewer?: RefOf<'app.bsky.feed.defs#generatorViewerState'>;
		indexedAt: string;
	};
	'app.bsky.feed.defs#generatorViewerState': {
		like?: AtUri;
	};
	'app.bsky.feed.defs#skeletonFeedPost': {
		post: AtUri;
		reason?: UnionOf<'app.bsky.feed.defs#skeletonReasonRepost'>;
	};
	'app.bsky.feed.defs#skeletonReasonRepost': {
		repost: AtUri;
	};
	'app.bsky.feed.defs#threadgateView': {
		uri?: AtUri;
		cid?: CID;
		record?: unknown;
		lists?: RefOf<'app.bsky.graph.defs#listViewBasic'>[];
	};
	'app.bsky.feed.describeFeedGenerator#feed': {
		uri: AtUri;
	};
	'app.bsky.feed.describeFeedGenerator#links': {
		privacyPolicy?: string;
		termsOfService?: string;
	};
	'app.bsky.feed.getLikes#like': {
		indexedAt: string;
		createdAt: string;
		actor: RefOf<'app.bsky.actor.defs#profileView'>;
	};
	'app.bsky.feed.post#replyRef': {
		root: RefOf<'com.atproto.repo.strongRef'>;
		parent: RefOf<'com.atproto.repo.strongRef'>;
	};
	/**
	 * Deprecated: use facets instead.
	 * @deprecated
	 */
	'app.bsky.feed.post#entity': {
		index: RefOf<'app.bsky.feed.post#textSlice'>;
		/**
		 * Expected values are 'mention' and 'link'.
		 */
		type: string;
		value: string;
	};
	/**
	 * Deprecated. Use app.bsky.richtext instead -- A text segment. Start is inclusive, end is exclusive. Indices are for utf16-encoded strings.
	 * @deprecated
	 */
	'app.bsky.feed.post#textSlice': {
		/**
		 * Minimum: 0
		 */
		start: number;
		/**
		 * Minimum: 0
		 */
		end: number;
	};
	/**
	 * Allow replies from actors mentioned in your post.
	 */
	'app.bsky.feed.threadgate#mentionRule': {};
	/**
	 * Allow replies from actors you follow.
	 */
	'app.bsky.feed.threadgate#followingRule': {};
	/**
	 * Allow replies from actors on a list.
	 */
	'app.bsky.feed.threadgate#listRule': {
		list: AtUri;
	};
	'app.bsky.graph.defs#listViewBasic': {
		uri: AtUri;
		cid: CID;
		/**
		 * Minimum string length: 1 \
		 * Maximum string length: 64
		 */
		name: string;
		purpose: RefOf<'app.bsky.graph.defs#listPurpose'>;
		avatar?: string;
		viewer?: RefOf<'app.bsky.graph.defs#listViewerState'>;
		indexedAt?: string;
	};
	'app.bsky.graph.defs#listView': {
		uri: AtUri;
		cid: CID;
		creator: RefOf<'app.bsky.actor.defs#profileView'>;
		/**
		 * Minimum string length: 1 \
		 * Maximum string length: 64
		 */
		name: string;
		purpose: RefOf<'app.bsky.graph.defs#listPurpose'>;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: RefOf<'app.bsky.richtext.facet'>[];
		avatar?: string;
		viewer?: RefOf<'app.bsky.graph.defs#listViewerState'>;
		indexedAt: string;
	};
	'app.bsky.graph.defs#listItemView': {
		subject: RefOf<'app.bsky.actor.defs#profileView'>;
	};
	'app.bsky.graph.defs#listPurpose':
		| 'app.bsky.graph.defs#modlist'
		| 'app.bsky.graph.defs#curatelist'
		| (string & {});
	'app.bsky.graph.defs#modlist': 'app.bsky.graph.defs#modlist';
	'app.bsky.graph.defs#curatelist': 'app.bsky.graph.defs#curatelist';
	'app.bsky.graph.defs#listViewerState': {
		muted?: boolean;
		blocked?: AtUri;
	};
	'app.bsky.notification.listNotifications#notification': {
		uri: AtUri;
		cid: CID;
		author: RefOf<'app.bsky.actor.defs#profileView'>;
		/**
		 * Expected values are 'like', 'repost', 'follow', 'mention', 'reply', and 'quote'.
		 */
		reason: 'like' | 'repost' | 'follow' | 'mention' | 'reply' | 'quote' | (string & {});
		reasonSubject?: AtUri;
		record: unknown;
		isRead: boolean;
		indexedAt: string;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
	};
	'app.bsky.richtext.facet': {
		index: RefOf<'app.bsky.richtext.facet#byteSlice'>;
		features: (
			| UnionOf<'app.bsky.richtext.facet#mention'>
			| UnionOf<'app.bsky.richtext.facet#link'>
			| UnionOf<'app.bsky.richtext.facet#tag'>
		)[];
	};
	/**
	 * A facet feature for actor mentions.
	 */
	'app.bsky.richtext.facet#mention': {
		did: DID;
	};
	/**
	 * A facet feature for links.
	 */
	'app.bsky.richtext.facet#link': {
		uri: string;
	};
	/**
	 * A hashtag.
	 */
	'app.bsky.richtext.facet#tag': {
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		tag: string;
	};
	/**
	 * A text segment. Start is inclusive, end is exclusive. Indices are for utf8-encoded strings.
	 */
	'app.bsky.richtext.facet#byteSlice': {
		/**
		 * Minimum: 0
		 */
		byteStart: number;
		/**
		 * Minimum: 0
		 */
		byteEnd: number;
	};
	'app.bsky.unspecced.defs#skeletonSearchPost': {
		uri: AtUri;
	};
	'app.bsky.unspecced.defs#skeletonSearchActor': {
		did: DID;
	};
	'com.atproto.admin.defs#statusAttr': {
		applied: boolean;
		ref?: string;
	};
	'com.atproto.admin.defs#actionView': {
		id: number;
		action: RefOf<'com.atproto.admin.defs#actionType'>;
		/**
		 * Indicates how long this action was meant to be in effect before automatically expiring.
		 */
		durationInHours?: number;
		subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
		subjectBlobCids: string[];
		createLabelVals?: string[];
		negateLabelVals?: string[];
		reason: string;
		createdBy: DID;
		createdAt: string;
		reversal?: RefOf<'com.atproto.admin.defs#actionReversal'>;
		resolvedReportIds: number[];
	};
	'com.atproto.admin.defs#actionViewDetail': {
		id: number;
		action: RefOf<'com.atproto.admin.defs#actionType'>;
		/**
		 * Indicates how long this action was meant to be in effect before automatically expiring.
		 */
		durationInHours?: number;
		subject:
			| UnionOf<'com.atproto.admin.defs#repoView'>
			| UnionOf<'com.atproto.admin.defs#repoViewNotFound'>
			| UnionOf<'com.atproto.admin.defs#recordView'>
			| UnionOf<'com.atproto.admin.defs#recordViewNotFound'>;
		subjectBlobs: RefOf<'com.atproto.admin.defs#blobView'>[];
		createLabelVals?: string[];
		negateLabelVals?: string[];
		reason: string;
		createdBy: DID;
		createdAt: string;
		reversal?: RefOf<'com.atproto.admin.defs#actionReversal'>;
		resolvedReports: RefOf<'com.atproto.admin.defs#reportView'>[];
	};
	'com.atproto.admin.defs#actionViewCurrent': {
		id: number;
		action: RefOf<'com.atproto.admin.defs#actionType'>;
		/**
		 * Indicates how long this action was meant to be in effect before automatically expiring.
		 */
		durationInHours?: number;
	};
	'com.atproto.admin.defs#actionReversal': {
		reason: string;
		createdBy: DID;
		createdAt: string;
	};
	'com.atproto.admin.defs#actionType': '#takedown' | '#flag' | '#acknowledge' | '#escalate' | (string & {});
	'com.atproto.admin.defs#takedown': 'com.atproto.admin.defs#takedown';
	'com.atproto.admin.defs#flag': 'com.atproto.admin.defs#flag';
	'com.atproto.admin.defs#acknowledge': 'com.atproto.admin.defs#acknowledge';
	'com.atproto.admin.defs#escalate': 'com.atproto.admin.defs#escalate';
	'com.atproto.admin.defs#reportView': {
		id: number;
		reasonType: RefOf<'com.atproto.moderation.defs#reasonType'>;
		reason?: string;
		subjectRepoHandle?: string;
		subject: UnionOf<'com.atproto.admin.defs#repoRef'> | UnionOf<'com.atproto.repo.strongRef'>;
		reportedBy: DID;
		createdAt: string;
		resolvedByActionIds: number[];
	};
	'com.atproto.admin.defs#reportViewDetail': {
		id: number;
		reasonType: RefOf<'com.atproto.moderation.defs#reasonType'>;
		reason?: string;
		subject:
			| UnionOf<'com.atproto.admin.defs#repoView'>
			| UnionOf<'com.atproto.admin.defs#repoViewNotFound'>
			| UnionOf<'com.atproto.admin.defs#recordView'>
			| UnionOf<'com.atproto.admin.defs#recordViewNotFound'>;
		reportedBy: DID;
		createdAt: string;
		resolvedByActions: RefOf<'com.atproto.admin.defs#actionView'>[];
	};
	'com.atproto.admin.defs#repoView': {
		did: DID;
		handle: Handle;
		email?: string;
		relatedRecords: unknown[];
		indexedAt: string;
		moderation: RefOf<'com.atproto.admin.defs#moderation'>;
		invitedBy?: RefOf<'com.atproto.server.defs#inviteCode'>;
		invitesDisabled?: boolean;
		inviteNote?: string;
	};
	'com.atproto.admin.defs#repoViewDetail': {
		did: DID;
		handle: Handle;
		email?: string;
		relatedRecords: unknown[];
		indexedAt: string;
		moderation: RefOf<'com.atproto.admin.defs#moderationDetail'>;
		labels?: RefOf<'com.atproto.label.defs#label'>[];
		invitedBy?: RefOf<'com.atproto.server.defs#inviteCode'>;
		invites?: RefOf<'com.atproto.server.defs#inviteCode'>[];
		invitesDisabled?: boolean;
		inviteNote?: string;
		emailConfirmedAt?: string;
	};
	'com.atproto.admin.defs#accountView': {
		did: DID;
		handle: Handle;
		email?: string;
		indexedAt: string;
		invitedBy?: RefOf<'com.atproto.server.defs#inviteCode'>;
		invites?: RefOf<'com.atproto.server.defs#inviteCode'>[];
		invitesDisabled?: boolean;
		emailConfirmedAt?: string;
		inviteNote?: string;
	};
	'com.atproto.admin.defs#repoViewNotFound': {
		did: DID;
	};
	'com.atproto.admin.defs#repoRef': {
		did: DID;
	};
	'com.atproto.admin.defs#repoBlobRef': {
		did: DID;
		cid: CID;
		recordUri?: AtUri;
	};
	'com.atproto.admin.defs#recordView': {
		uri: AtUri;
		cid: CID;
		value: unknown;
		blobCids: CID[];
		indexedAt: string;
		moderation: RefOf<'com.atproto.admin.defs#moderation'>;
		repo: RefOf<'com.atproto.admin.defs#repoView'>;
	};
	'com.atproto.admin.defs#recordViewDetail': {
		uri: AtUri;
		cid: CID;
		value: unknown;
		blobs: RefOf<'com.atproto.admin.defs#blobView'>[];
		labels?: RefOf<'com.atproto.label.defs#label'>[];
		indexedAt: string;
		moderation: RefOf<'com.atproto.admin.defs#moderationDetail'>;
		repo: RefOf<'com.atproto.admin.defs#repoView'>;
	};
	'com.atproto.admin.defs#recordViewNotFound': {
		uri: AtUri;
	};
	'com.atproto.admin.defs#moderation': {
		currentAction?: RefOf<'com.atproto.admin.defs#actionViewCurrent'>;
	};
	'com.atproto.admin.defs#moderationDetail': {
		currentAction?: RefOf<'com.atproto.admin.defs#actionViewCurrent'>;
		actions: RefOf<'com.atproto.admin.defs#actionView'>[];
		reports: RefOf<'com.atproto.admin.defs#reportView'>[];
	};
	'com.atproto.admin.defs#blobView': {
		cid: CID;
		mimeType: string;
		size: number;
		createdAt: string;
		details?: UnionOf<'com.atproto.admin.defs#imageDetails'> | UnionOf<'com.atproto.admin.defs#videoDetails'>;
		moderation?: RefOf<'com.atproto.admin.defs#moderation'>;
	};
	'com.atproto.admin.defs#imageDetails': {
		width: number;
		height: number;
	};
	'com.atproto.admin.defs#videoDetails': {
		width: number;
		height: number;
		length: number;
	};
	/**
	 * Metadata tag on an atproto resource (eg, repo or record)
	 */
	'com.atproto.label.defs#label': {
		/**
		 * DID of the actor who created this label
		 */
		src: DID;
		/**
		 * AT URI of the record, repository (account), or other resource which this label applies to
		 */
		uri: string;
		/**
		 * optionally, CID specifying the specific version of 'uri' resource this label applies to
		 */
		cid?: CID;
		/**
		 * the short string name of the value or type of this label \
		 * Maximum string length: 128
		 */
		val: string;
		/**
		 * if true, this is a negation label, overwriting a previous label
		 */
		neg?: boolean;
		/**
		 * timestamp when this label was created
		 */
		cts: string;
	};
	/**
	 * Metadata tags on an atproto record, published by the author within the record.
	 */
	'com.atproto.label.defs#selfLabels': {
		/**
		 * Maximum array length: 10
		 */
		values: RefOf<'com.atproto.label.defs#selfLabel'>[];
	};
	/**
	 * Metadata tag on an atproto record, published by the author within the record. Note -- schemas should use #selfLabels, not #selfLabel.
	 */
	'com.atproto.label.defs#selfLabel': {
		/**
		 * the short string name of the value or type of this label \
		 * Maximum string length: 128
		 */
		val: string;
	};
	'com.atproto.label.subscribeLabels#labels': {
		seq: number;
		labels: RefOf<'com.atproto.label.defs#label'>[];
	};
	'com.atproto.label.subscribeLabels#info': {
		name: 'OutdatedCursor' | (string & {});
		message?: string;
	};
	'com.atproto.moderation.defs#reasonType':
		| 'com.atproto.moderation.defs#reasonSpam'
		| 'com.atproto.moderation.defs#reasonViolation'
		| 'com.atproto.moderation.defs#reasonMisleading'
		| 'com.atproto.moderation.defs#reasonSexual'
		| 'com.atproto.moderation.defs#reasonRude'
		| 'com.atproto.moderation.defs#reasonOther'
		| (string & {});
	'com.atproto.moderation.defs#reasonSpam': 'com.atproto.moderation.defs#reasonSpam';
	'com.atproto.moderation.defs#reasonViolation': 'com.atproto.moderation.defs#reasonViolation';
	'com.atproto.moderation.defs#reasonMisleading': 'com.atproto.moderation.defs#reasonMisleading';
	'com.atproto.moderation.defs#reasonSexual': 'com.atproto.moderation.defs#reasonSexual';
	'com.atproto.moderation.defs#reasonRude': 'com.atproto.moderation.defs#reasonRude';
	'com.atproto.moderation.defs#reasonOther': 'com.atproto.moderation.defs#reasonOther';
	/**
	 * Create a new record.
	 */
	'com.atproto.repo.applyWrites#create': {
		collection: string;
		/**
		 * Maximum string length: 15
		 */
		rkey?: string;
		value: unknown;
	};
	/**
	 * Update an existing record.
	 */
	'com.atproto.repo.applyWrites#update': {
		collection: string;
		rkey: string;
		value: unknown;
	};
	/**
	 * Delete an existing record.
	 */
	'com.atproto.repo.applyWrites#delete': {
		collection: string;
		rkey: string;
	};
	'com.atproto.repo.listRecords#record': {
		uri: AtUri;
		cid: CID;
		value: unknown;
	};
	'com.atproto.repo.strongRef': {
		uri: AtUri;
		cid: CID;
	};
	'com.atproto.server.createAppPassword#appPassword': {
		name: string;
		password: string;
		createdAt: string;
	};
	'com.atproto.server.createInviteCodes#accountCodes': {
		account: string;
		codes: string[];
	};
	'com.atproto.server.defs#inviteCode': {
		code: string;
		available: number;
		disabled: boolean;
		forAccount: string;
		createdBy: string;
		createdAt: string;
		uses: RefOf<'com.atproto.server.defs#inviteCodeUse'>[];
	};
	'com.atproto.server.defs#inviteCodeUse': {
		usedBy: DID;
		usedAt: string;
	};
	'com.atproto.server.describeServer#links': {
		privacyPolicy?: string;
		termsOfService?: string;
	};
	'com.atproto.server.listAppPasswords#appPassword': {
		name: string;
		createdAt: string;
	};
	'com.atproto.sync.listRepos#repo': {
		did: DID;
		head: CID;
		rev: string;
	};
	'com.atproto.sync.subscribeRepos#commit': {
		seq: number;
		rebase: boolean;
		tooBig: boolean;
		repo: DID;
		commit: unknown;
		prev?: unknown;
		/**
		 * The rev of the emitted commit
		 */
		rev: string;
		/**
		 * The rev of the last emitted commit from this repo
		 */
		since: string;
		/**
		 * CAR file containing relevant blocks
		 */
		blocks: unknown;
		/**
		 * Maximum array length: 200
		 */
		ops: RefOf<'com.atproto.sync.subscribeRepos#repoOp'>[];
		blobs: unknown[];
		time: string;
	};
	'com.atproto.sync.subscribeRepos#handle': {
		seq: number;
		did: DID;
		handle: Handle;
		time: string;
	};
	'com.atproto.sync.subscribeRepos#migrate': {
		seq: number;
		did: DID;
		migrateTo: string;
		time: string;
	};
	'com.atproto.sync.subscribeRepos#tombstone': {
		seq: number;
		did: DID;
		time: string;
	};
	'com.atproto.sync.subscribeRepos#info': {
		name: 'OutdatedCursor' | (string & {});
		message?: string;
	};
	/**
	 * A repo operation, ie a write of a single record. For creates and updates, cid is the record's CID as of this operation. For deletes, it's null.
	 */
	'com.atproto.sync.subscribeRepos#repoOp': {
		action: 'create' | 'update' | 'delete' | (string & {});
		path: string;
		cid: unknown;
	};
}

export interface Records {
	'app.bsky.actor.profile': {
		/**
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		displayName?: string;
		/**
		 * Maximum string length: 2560 \
		 * Maximum grapheme length: 256
		 */
		description?: string;
		avatar?: AtBlob<`image/png` | `image/jpeg`>;
		banner?: AtBlob<`image/png` | `image/jpeg`>;
		labels?: UnionOf<'com.atproto.label.defs#selfLabels'>;
	};
	/**
	 * A declaration of the existence of a feed generator
	 */
	'app.bsky.feed.generator': {
		did: DID;
		/**
		 * Maximum string length: 240 \
		 * Maximum grapheme length: 24
		 */
		displayName: string;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: RefOf<'app.bsky.richtext.facet'>[];
		avatar?: AtBlob<`image/png` | `image/jpeg`>;
		labels?: UnionOf<'com.atproto.label.defs#selfLabels'>;
		createdAt: string;
	};
	'app.bsky.feed.like': {
		subject: RefOf<'com.atproto.repo.strongRef'>;
		createdAt: string;
	};
	'app.bsky.feed.post': {
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		text: string;
		/**
		 * Deprecated: replaced by app.bsky.richtext.facet.
		 * @deprecated
		 */
		entities?: RefOf<'app.bsky.feed.post#entity'>[];
		facets?: RefOf<'app.bsky.richtext.facet'>[];
		reply?: RefOf<'app.bsky.feed.post#replyRef'>;
		embed?:
			| UnionOf<'app.bsky.embed.images'>
			| UnionOf<'app.bsky.embed.external'>
			| UnionOf<'app.bsky.embed.record'>
			| UnionOf<'app.bsky.embed.recordWithMedia'>;
		/**
		 * Maximum array length: 3
		 */
		langs?: string[];
		labels?: UnionOf<'com.atproto.label.defs#selfLabels'>;
		/**
		 * Additional non-inline tags describing this post. \
		 * Maximum array length: 8 \
		 * Maximum string length: 640 \
		 * Maximum grapheme length: 64
		 */
		tags?: string[];
		createdAt: string;
	};
	'app.bsky.feed.repost': {
		subject: RefOf<'com.atproto.repo.strongRef'>;
		createdAt: string;
	};
	/**
	 * Defines interaction gating rules for a thread. The rkey of the threadgate record should match the rkey of the thread's root post.
	 */
	'app.bsky.feed.threadgate': {
		post: AtUri;
		/**
		 * Maximum array length: 5
		 */
		allow?: (
			| UnionOf<'app.bsky.feed.threadgate#mentionRule'>
			| UnionOf<'app.bsky.feed.threadgate#followingRule'>
			| UnionOf<'app.bsky.feed.threadgate#listRule'>
		)[];
		createdAt: string;
	};
	/**
	 * A block.
	 */
	'app.bsky.graph.block': {
		subject: DID;
		createdAt: string;
	};
	/**
	 * A social follow.
	 */
	'app.bsky.graph.follow': {
		subject: DID;
		createdAt: string;
	};
	/**
	 * A declaration of a list of actors.
	 */
	'app.bsky.graph.list': {
		purpose: RefOf<'app.bsky.graph.defs#listPurpose'>;
		/**
		 * Minimum string length: 1 \
		 * Maximum string length: 64
		 */
		name: string;
		/**
		 * Maximum string length: 3000 \
		 * Maximum grapheme length: 300
		 */
		description?: string;
		descriptionFacets?: RefOf<'app.bsky.richtext.facet'>[];
		avatar?: AtBlob<`image/png` | `image/jpeg`>;
		labels?: UnionOf<'com.atproto.label.defs#selfLabels'>;
		createdAt: string;
	};
	/**
	 * A block of an entire list of actors.
	 */
	'app.bsky.graph.listblock': {
		subject: AtUri;
		createdAt: string;
	};
	/**
	 * An item under a declared list of actors
	 */
	'app.bsky.graph.listitem': {
		subject: DID;
		list: AtUri;
		createdAt: string;
	};
}
